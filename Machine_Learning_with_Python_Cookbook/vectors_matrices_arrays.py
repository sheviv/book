# ch_1_Векторы, матрицы, массивы

import numpy as np
import scipy as sp
from scipy import sparse

matrix = np.array([[1, 2, 3],
                   [4, 5, 6],
                   [7, 8, 9]])

# create matrix
# matrix_oj = np.mat([[1, 2],
#                     [1, 2],
#                     [1, 2]])

# Создать разреженную матрицу:
# matrix = np.array([[0, 0],
#                    [0, 1],
#                    [3, 0]])
# Создать сжатую разреженную матрицу-строку (CSR-матрицу)
# matrix_sparse = sparse.csr_matrix(matrix)
# в ней хранятся только ненулевые значения, представляют индексы ненулевых значений (с отсчетом от нуля)

# првоерка кол-ва элементов в матрице
# matrix.size()

# првоерка кол-ва размерностей в матрице
# matrix.ndim()

# Применить функцию к нескольким элементам массива
# matrix = np.array([[1, 2, 3],
#                    [4, 5, 6],
#                    [7, 8, 9]])
# add 100
# add_100 = lambda i: i + 100
# create vectorize function
# vectorize_add_100 = np.vectorize(add_100)
# apply function to all elements matrix
# vectorize_add_100(matrix)
# или используя трансляцию применим функцию к нескольким элементам массива
# matrix + 100

# максимальный и минимальный элемент в матрице
# np.max(matrix)
# np.min(matrix)

# максимальный элемент в каждом столбце
# np.max(matrix, axis=0)  # 0 - строка, 1 - столбец

# вернуть среднее значение
# np.mean(matrix)
# вернуть дисперсию
# np.var(matrix)
# вернуть стандартное отклонение
# np.std(matrix)

# Реформировать матрицу в матрицу 2x6
# matrix.reshape(2, 6)

# Реформировать матрицу в одну строку и столько столбцов, сколько необходимо:
# matrix.reshape(1, -1)

# Транспонировать вектор-строку
# np.array([[1, 2, 3, 4, 5, 6]]).Т

# преобразоваие матрицы в одномерный массив.
# Сгладить матрицу
# matrix.flatten()

# Вернуть ранг матрицы
# np.linalg.matrix_rank(matrix)

# Вернуть определитель матрицы
# np.linalg.det(matrix)

# Вернуть диагональные элементы
# matrix.diagonal()

# Вернуть диагональ на одну выше главной диагонали
# matrix.diagonal(offset=1)
# Вернуть диагональ на одну ниже главной диагонали
# matrix.diagonal(offset=-1)

# след матрицы - суммой элементов главной диагонали
# matrix.trace() or sum(matrix.diagonal())

# собственные значения и собственные векторы квадратной матрицы — это векторы, которые при при-
# менении этого преобразования изменяются только в масштабе (а не в направлении).
# Вычислить собственные значения и собственные векторы
# eigenvalues, eigenvectors = np.linalg.eig(matrix)

# скалярное произведение двух векторов
# np.dot(vector_a, vector_b) or vector_a @ vector_b

# Сложить две матрицы
# np.add(matrix_a, matrix_b) or matrix_a + matrix_b
# Вычесть из одной матрицы другую
# np.subtract(matrix_a, matrix_b)

# Перемножить две матрицы поэлементно
# matrix_a * matrix_b

# Вычислить обратную матрицу
# np.linalg.inv(matrix)

# Задать начальное значение для генератора псевдослучайных чисел
# np.random.seed(0)
# Сгенерировать три случайных вещественных числа между 0.0 и 1.0
# np.random.random(3)
# Сгенерировать три случайных целых числа между 1 и 10
# np.random.randint(0, 11, 3)

# Извлечь три числа из нормального распределения со средним, равным 0.0, и стандартным отклонением, равным 1.0
# np.random.normal(0.0, 1.0, 3)
# Извлечь три числа из логистического распределения со средним, равным 0.0, и масштабом, равным 1.0
# np.random.logistic(0.0, 1.0, 3)
# Извлечь три числа, которые больше или равны 1.0 и меньше 2.0
# np.random.uniform(1.0, 2.0, 3)